(()=>{"use strict";!async function(){const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU is not supported on this device or browser.");const n=e.info;console.log(n.vendor),console.log(n.architecture);const r=e.features.has("timestamp-query");if(!r)return void console.error("Timestamp queries are not supported on this device.");const t=await e.requestDevice({requiredFeatures:["timestamp-query"]}),o=document.querySelector("canvas");if(!o)throw new Error("Canvas element not found!");const i=o.getContext("webgpu");if(!i)throw new Error("WebGPU is not supported on this device or browser.");const{querySet:a,resolveBuffer:s,resultBuffer:c}=(()=>{if(!r)return{};const e=t.createQuerySet({type:"timestamp",count:2}),n=t.createBuffer({size:8*e.count,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC});return{querySet:e,resolveBuffer:n,resultBuffer:t.createBuffer({size:n.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})}})();if(!a)throw new Error("querySet is not defined!");const f=navigator.gpu.getPreferredCanvasFormat();i.configure({device:t,format:f,alphaMode:"opaque"});const u={position:[0,0,5],direction:[0,0,0],padding:0},l=t.createBuffer({size:48,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(l,0,new Float32Array([...u.position,...u.direction,u.padding]));const p=t.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),d=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),m=new Float32Array([-1,-1,1,-1,-1,1,1,1]),v=t.createBuffer({size:m.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(v.getMappedRange()).set(m),v.unmap();const g=t.createShaderModule({code:"@group(0) @binding(0) var<uniform> camera: Camera;\n@group(0) @binding(1) var<uniform> time: f32;\n\nstruct Camera {\n    position: vec3<f32>,\n    direction: vec3<f32>,\n    up: vec3<f32>,\n    right: vec3<f32>,\n};\n\nfn mandelbulbDE(pos: vec3<f32>, power: f32, maxIterations: u32) -> f32 {\n    var z = pos;\n    var dr = 1.0;\n    var r = 0.0;\n\n    for (var i = 0u; i < maxIterations; i = i + 1u) {\n        r = length(z);\n\n        if (r > 2.0) {\n            break;\n        }\n\n        // Convert to spherical coordinates\n        let theta = acos(z.z / r);\n        let phi = atan2(z.y, z.x);\n\n        // Scale and rotate\n        let zr = pow(r, power);\n        let newTheta = theta * power;\n        let newPhi = phi * power;\n\n        // Convert back to Cartesian coordinates\n        z = zr * vec3<f32>(\n            sin(newTheta) * cos(newPhi),\n            sin(newTheta) * sin(newPhi),\n            cos(newTheta)\n        );\n\n        z = z + pos;\n        dr = dr * power * r + 1.0;\n    }\n\n    return 0.5 * log(r) * r / dr;\n}\n\nfn calculateNormal(pos: vec3<f32>, power: f32, maxIterations: u32) -> vec3<f32> {\n    let epsilon = 0.001;\n\n    let dx = mandelbulbDE(pos + vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations) -\n             mandelbulbDE(pos - vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations);\n    let dy = mandelbulbDE(pos + vec3<f32>(0.0, epsilon, 0.0), power, maxIterations) -\n             mandelbulbDE(pos - vec3<f32>(0.0, epsilon, 0.0), power, maxIterations);\n    let dz = mandelbulbDE(pos + vec3<f32>(0.0, 0.0, epsilon), power, maxIterations) -\n             mandelbulbDE(pos - vec3<f32>(0.0, 0.0, epsilon), power, maxIterations);\n\n    return normalize(vec3<f32>(dx, dy, dz));\n}\n\n\n// Raymarching Function\nfn raymarch(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxSteps: i32, maxDistance: f32, epsilon: f32) -> vec3<f32> {\n    var pos = rayOrigin;\n    for (var i = 0; i < maxSteps; i = i + 1) {\n\n        let mandelbulbPower = 1.0 + 3.5 * (sin(time) + 1.0);\n\n        let distance = mandelbulbDE(pos, mandelbulbPower, 32u);\n\n        //let distance = sphereDE(pos, vec3<f32>(0.0, 0.0, 0.0), 1.0);\n        if (distance < epsilon) {\n            //let normal = calculateNormal(pos);\n            let normal = calculateNormal(pos, 8.0, 32u);\n\n            // Light direction\n            let lightDirection = normalize(vec3<f32>(3.0, -3.0, 1.0));\n\n            // Lambertian shading\n            let diffuse = max(dot(normal, lightDirection), 0.0);\n\n            // View direction (camera)\n            let viewDirection = normalize(rayOrigin - pos);\n\n            // Reflect light direction around the normal\n            let reflection = reflect(-lightDirection, normal);\n\n            // Specular shading\n            let shininess = 48.0; // Adjust for sharper or softer highlights\n            let specular = pow(max(dot(viewDirection, reflection), 0.0), shininess);\n\n            // Ambient light\n            let ambient = 0.1;\n\n            // Combine components\n            return vec3<f32>(1.0, 0.0, 0.0) * (diffuse + ambient) + vec3<f32>(1.0) * specular; // Add specular\n        }\n        if (distance > maxDistance) {\n            break;\n        }\n        pos = pos + rayDirection * distance;\n    }\n    return vec3<f32>(0.0, 0.0, 0.0);\n}\n\n@fragment\nfn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {\n    let resolution = vec2<f32>(800.0, 600.0);\n    let uv = (fragCoord.xy / resolution) * 2.0 - vec2<f32>(1.0, 1.0);\n\n    let aspectRatio = resolution.x / resolution.y;\n    let fov = 60.0 * 3.14159 / 180.0;\n\n    // Camera properties\n    let cameraPosition = vec3<f32>(0.0, 0.0, 5.0);\n    let object = vec3<f32>(0.0, 0.0, 0.0);\n    let forward = normalize(object - cameraPosition);\n    let up = vec3<f32>(0.0, 1.0, 0.0);\n    let right = normalize(cross(forward, up));\n    let adjustedUp = cross(right, forward);\n    \n    let rayDirection = normalize(\n        forward +\n        right * uv.x * aspectRatio * tan(fov / 2.0) +\n        adjustedUp * uv.y * tan(fov / 2.0)\n    );\n\n    let color = raymarch(cameraPosition, rayDirection, 256, 50.0, 0.001);\n    return vec4<f32>(color, 1.0);\n}\n\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {\n\n    var positions = array<vec2<f32>, 3>(\n        vec2<f32>(-1.0, -1.0),\n        vec2<f32>(3.0, -1.0),\n        vec2<f32>(-1.0, 3.0)\n    );\n\n    let position = positions[vertexIndex];\n    return vec4<f32>(position, 0.0, 1.0);\n}\n\n"}),b=t.createPipelineLayout({bindGroupLayouts:[d]}),w=t.createRenderPipeline({layout:b,vertex:{module:g,entryPoint:"vs_main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:g,entryPoint:"fs_main",targets:[{format:f}]},primitive:{topology:"triangle-strip"}}),h=t.createBindGroup({layout:d,entries:[{binding:0,resource:{buffer:l}},{binding:1,resource:{buffer:p}}]});let y=performance.now(),P=0;!function e(){const n=performance.now(),o=n-y;y=n,P+=.001*o,t.queue.writeBuffer(p,0,new Float32Array([P]));const s={position:[0,0,5],direction:[0,0,-1]};t.queue.writeBuffer(l,0,new Float32Array([...s.position,...s.direction]));const c=t.createCommandEncoder();if(!i)throw new Error("WebGPU is not supported on this device or browser.");const f=i.getCurrentTexture().createView(),u=c.beginRenderPass({colorAttachments:[{view:f,loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}],...r&&a&&{timestampWrites:{querySet:a,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}}});u.setPipeline(w),u.setBindGroup(0,h),u.setVertexBuffer(0,v),u.draw(4),u.end(),t.queue.submit([c.finish()]),requestAnimationFrame(e)}()}()})();
//# sourceMappingURL=main.bundle.js.map