{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgpu/./src/main.ts","webpack://webgpu/./src/shader.wgsl"],"sourcesContent":["import shader from './shader.wgsl';\nasync function main() {\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        throw new Error('WebGPU is not supported on this device or browser.');\n    }\n    const adapterInfo = adapter.info;\n    console.log(adapterInfo.vendor);\n    console.log(adapterInfo.architecture);\n    const canTimestamp = adapter.features.has(\"timestamp-query\");\n    if (!canTimestamp) {\n        console.error(\"Timestamp queries are not supported on this device.\");\n        return;\n    }\n    const device = await adapter.requestDevice({\n        requiredFeatures: ['timestamp-query'],\n    });\n    const limits = device.limits;\n    console.log(limits.maxComputeWorkgroupSizeX);\n    const canvas = document.querySelector('canvas');\n    if (!canvas) {\n        throw new Error('Canvas element not found!');\n    }\n    const context = canvas.getContext('webgpu');\n    if (!context) {\n        throw new Error('WebGPU is not supported on this device or browser.');\n    }\n    const { querySet, resolveBuffer, resultBuffer } = (() => {\n        if (!canTimestamp) {\n            return {};\n        }\n        const querySet = device.createQuerySet({\n            type: 'timestamp',\n            count: 2,\n        });\n        const resolveBuffer = device.createBuffer({\n            size: querySet.count * 8,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n        });\n        const resultBuffer = device.createBuffer({\n            size: resolveBuffer.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        return { querySet, resolveBuffer, resultBuffer };\n    })();\n    if (!querySet) {\n        throw new Error('querySet is not defined!');\n    }\n    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n    context.configure({\n        device: device,\n        format: presentationFormat,\n        alphaMode: \"opaque\",\n    });\n    const cameraUniform = {\n        position: [0.0, 0.0, 5.0],\n        direction: [0.0, 0.0, 0.0],\n        padding: 0.0,\n    };\n    // Define camera uniform\n    const cameraUniformBuffer = device.createBuffer({\n        size: 48,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(cameraUniformBuffer, 0, new Float32Array([\n        ...cameraUniform.position,\n        ...cameraUniform.direction,\n        cameraUniform.padding,\n    ]));\n    const timeUniformBuffer = device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n    const vertices = new Float32Array([\n        -1, -1,\n        1, -1,\n        -1, 1,\n        1, 1,\n    ]);\n    const vertexBuffer = device.createBuffer({\n        size: vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX,\n        mappedAtCreation: true,\n    });\n    new Float32Array(vertexBuffer.getMappedRange()).set(vertices);\n    vertexBuffer.unmap();\n    // Shader modules\n    const shaderModule = device.createShaderModule({\n        code: shader,\n    });\n    const pipelineLayout = device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayout],\n    });\n    // Pipeline\n    const pipeline = device.createRenderPipeline({\n        layout: pipelineLayout,\n        vertex: {\n            module: shaderModule,\n            entryPoint: \"vs_main\",\n            buffers: [\n                {\n                    arrayStride: 8,\n                    attributes: [\n                        {\n                            shaderLocation: 0,\n                            offset: 0,\n                            format: \"float32x2\",\n                        },\n                    ],\n                },\n            ],\n        },\n        fragment: {\n            module: shaderModule,\n            entryPoint: \"fs_main\",\n            targets: [{ format: presentationFormat }],\n        },\n        primitive: {\n            topology: \"triangle-strip\",\n        },\n    });\n    //const layout = pipeline.getBindGroupLayout(0); // Get the inferred layout\n    const bindGroup = device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: { buffer: cameraUniformBuffer },\n            },\n            {\n                binding: 1,\n                resource: { buffer: timeUniformBuffer },\n            }\n        ],\n    });\n    let lastTime = performance.now();\n    let totalTime = 0.0;\n    const animationSpeed = 0.001;\n    let gpuTimes = [];\n    const workgroupSize = 64;\n    const numWorkgroups = Math.ceil(1048576 / workgroupSize);\n    // Render loop\n    function render() {\n        const now = performance.now();\n        const deltaTime = now - lastTime;\n        lastTime = now;\n        totalTime += deltaTime * animationSpeed;\n        device.queue.writeBuffer(timeUniformBuffer, 0, new Float32Array([totalTime]));\n        const camera = {\n            position: [0.0, 0.0, 5.0],\n            direction: [0.0, 0.0, -1.0],\n        };\n        device.queue.writeBuffer(cameraUniformBuffer, 0, new Float32Array([...camera.position, ...camera.direction]));\n        const commandEncoder = device.createCommandEncoder();\n        const computePass = commandEncoder.beginComputePass();\n        if (!context) {\n            throw new Error('WebGPU is not supported on this device or browser.');\n        }\n        const textureView = context.getCurrentTexture().createView();\n        const renderPass = commandEncoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: textureView,\n                    loadOp: \"clear\",\n                    clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                    storeOp: \"store\",\n                },\n            ],\n            ...(canTimestamp && querySet && {\n                timestampWrites: {\n                    querySet: querySet,\n                    beginningOfPassWriteIndex: 0,\n                    endOfPassWriteIndex: 1,\n                },\n            }),\n        });\n        renderPass.setPipeline(pipeline);\n        renderPass.setBindGroup(0, bindGroup);\n        renderPass.setVertexBuffer(0, vertexBuffer);\n        renderPass.draw(4);\n        renderPass.end();\n        if (canTimestamp && querySet) {\n            commandEncoder.resolveQuerySet(querySet, 0, querySet.count, resolveBuffer, 0);\n            if (resultBuffer.mapState === 'unmapped') {\n                commandEncoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, resultBuffer.size);\n            }\n        }\n        device.queue.submit([commandEncoder.finish()]);\n        if (canTimestamp && resultBuffer && resultBuffer.mapState === 'unmapped') {\n            resultBuffer.mapAsync(GPUMapMode.READ).then(() => {\n                const times = new BigInt64Array(resultBuffer.getMappedRange());\n                const gpuTime = Number(times[1] - times[0]);\n                gpuTimes.push(`${(gpuTime / 1000).toFixed(1)}µs`);\n                //console.log(`${(gpuTime / 1000).toFixed(1)}µs`);\n                resultBuffer.unmap();\n                /* Uncomment to record results to files\n                if (gpuTimes.length >= maxGpuTimes) {\n                    const blob = new Blob([gpuTimes.join('\\n')], { type: 'text/plain' });\n                    const link = document.createElement('a');\n                    link.href = URL.createObjectURL(blob);\n                    link.download = 'gpu_times.txt';\n                    link.click();  // Automatically download the file\n    \n                    // Reset GPU times for next collection\n                    gpuTimes = [];\n                }*/\n            }).catch(error => {\n                console.error('Error mapping result buffer:', error);\n            });\n        }\n        // Request next frame\n        requestAnimationFrame(render);\n    }\n    render();\n}\nmain();\n","export default \"@group(0) @binding(0) var<uniform> camera: Camera;\\n@group(0) @binding(1) var<uniform> time: f32;\\n\\nstruct Camera {\\n    position: vec3<f32>,\\n    direction: vec3<f32>,\\n    up: vec3<f32>,\\n    right: vec3<f32>,\\n};\\n\\nfn mandelbulbDE(pos: vec3<f32>, power: f32, maxIterations: u32) -> f32 {\\n    var z = pos;\\n    var dr = 1.0;\\n    var r = 0.0;\\n\\n    for (var i = 0u; i < maxIterations; i = i + 1u) {\\n        r = length(z);\\n\\n        if (r > 2.0) {\\n            break;\\n        }\\n\\n        // Convert to spherical coordinates\\n        let theta = acos(z.z / r);\\n        let phi = atan2(z.y, z.x);\\n\\n        // Scale and rotate\\n        let zr = pow(r, power);\\n        let newTheta = theta * power;\\n        let newPhi = phi * power;\\n\\n        // Convert back to Cartesian coordinates\\n        z = zr * vec3<f32>(\\n            sin(newTheta) * cos(newPhi),\\n            sin(newTheta) * sin(newPhi),\\n            cos(newTheta)\\n        );\\n\\n        z = z + pos;\\n        dr = dr * power * r + 1.0;\\n    }\\n\\n    return 0.5 * log(r) * r / dr;\\n}\\n\\nfn calculateNormal(pos: vec3<f32>, power: f32, maxIterations: u32) -> vec3<f32> {\\n    let epsilon = 0.001;\\n\\n    let dx = mandelbulbDE(pos + vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations);\\n    let dy = mandelbulbDE(pos + vec3<f32>(0.0, epsilon, 0.0), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(0.0, epsilon, 0.0), power, maxIterations);\\n    let dz = mandelbulbDE(pos + vec3<f32>(0.0, 0.0, epsilon), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(0.0, 0.0, epsilon), power, maxIterations);\\n\\n    return normalize(vec3<f32>(dx, dy, dz));\\n}\\n\\n\\n// Raymarching Function\\nfn raymarch(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxSteps: i32, maxDistance: f32, epsilon: f32) -> vec3<f32> {\\n    var pos = rayOrigin;\\n    for (var i = 0; i < maxSteps; i = i + 1) {\\n\\n        let mandelbulbPower = 1.0 + 3.5 * (sin(time) + 1.0);\\n\\n        let distance = mandelbulbDE(pos, mandelbulbPower, 32u);\\n\\n        //let distance = sphereDE(pos, vec3<f32>(0.0, 0.0, 0.0), 1.0);\\n        if (distance < epsilon) {\\n            //let normal = calculateNormal(pos);\\n            let normal = calculateNormal(pos, 8.0, 32u);\\n\\n            // Light direction\\n            let lightDirection = normalize(vec3<f32>(3.0, -3.0, 1.0));\\n\\n            // Lambertian shading\\n            let diffuse = max(dot(normal, lightDirection), 0.0);\\n\\n            // View direction (camera)\\n            let viewDirection = normalize(rayOrigin - pos);\\n\\n            // Reflect light direction around the normal\\n            let reflection = reflect(-lightDirection, normal);\\n\\n            // Specular shading\\n            let shininess = 48.0; // Adjust for sharper or softer highlights\\n            let specular = pow(max(dot(viewDirection, reflection), 0.0), shininess);\\n\\n            // Ambient light\\n            let ambient = 0.1;\\n\\n            // Combine components\\n            return vec3<f32>(1.0, 0.0, 0.0) * (diffuse + ambient) + vec3<f32>(1.0) * specular; // Add specular\\n        }\\n        if (distance > maxDistance) {\\n            break;\\n        }\\n        pos = pos + rayDirection * distance;\\n    }\\n    return vec3<f32>(0.0, 0.0, 0.0);\\n}\\n\\n@fragment\\nfn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {\\n    let resolution = vec2<f32>(800.0, 600.0);\\n    let uv = (fragCoord.xy / resolution) * 2.0 - vec2<f32>(1.0, 1.0);\\n\\n    let aspectRatio = resolution.x / resolution.y;\\n    let fov = 60.0 * 3.14159 / 180.0;\\n\\n    // Camera properties\\n    let cameraPosition = vec3<f32>(0.0, 0.0, 5.0);\\n    let object = vec3<f32>(0.0, 0.0, 0.0);\\n    let forward = normalize(object - cameraPosition);\\n    let up = vec3<f32>(0.0, 1.0, 0.0);\\n    let right = normalize(cross(forward, up));\\n    let adjustedUp = cross(right, forward);\\n    \\n    let rayDirection = normalize(\\n        forward +\\n        right * uv.x * aspectRatio * tan(fov / 2.0) +\\n        adjustedUp * uv.y * tan(fov / 2.0)\\n    );\\n\\n    let color = raymarch(cameraPosition, rayDirection, 256, 50.0, 0.001);\\n    return vec4<f32>(color, 1.0);\\n}\\n\\n\\n@vertex\\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {\\n\\n    var positions = array<vec2<f32>, 3>(\\n        vec2<f32>(-1.0, -1.0),\\n        vec2<f32>(3.0, -1.0),\\n        vec2<f32>(-1.0, 3.0)\\n    );\\n\\n    let position = positions[vertexIndex];\\n    return vec4<f32>(position, 0.0, 1.0);\\n}\\n\\n\""],"names":["async","adapter","navigator","gpu","requestAdapter","Error","adapterInfo","info","console","log","vendor","architecture","canTimestamp","features","has","error","device","requestDevice","requiredFeatures","limits","maxComputeWorkgroupSizeX","canvas","document","querySelector","context","getContext","querySet","resolveBuffer","resultBuffer","createQuerySet","type","count","createBuffer","size","usage","GPUBufferUsage","QUERY_RESOLVE","COPY_SRC","COPY_DST","MAP_READ","presentationFormat","getPreferredCanvasFormat","configure","format","alphaMode","cameraUniform","position","direction","padding","cameraUniformBuffer","UNIFORM","queue","writeBuffer","Float32Array","timeUniformBuffer","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","VERTEX","buffer","vertices","vertexBuffer","byteLength","mappedAtCreation","getMappedRange","set","unmap","shaderModule","createShaderModule","code","pipelineLayout","createPipelineLayout","bindGroupLayouts","pipeline","createRenderPipeline","layout","vertex","module","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","bindGroup","createBindGroup","resource","lastTime","performance","now","totalTime","gpuTimes","Math","ceil","render","deltaTime","camera","commandEncoder","createCommandEncoder","beginComputePass","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","timestampWrites","beginningOfPassWriteIndex","endOfPassWriteIndex","setPipeline","setBindGroup","setVertexBuffer","draw","end","resolveQuerySet","mapState","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","then","times","BigInt64Array","gpuTime","Number","push","toFixed","catch","requestAnimationFrame","main"],"sourceRoot":""}