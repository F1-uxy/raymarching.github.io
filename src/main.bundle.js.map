{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgpu/./src/main.ts","webpack://webgpu/./src/shader.wgsl"],"sourcesContent":["import shader from './shader.wgsl';\nasync function main() {\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        throw new Error('WebGPU is not supported on this device or browser.');\n    }\n    const adapterInfo = adapter.info;\n    console.log(adapterInfo.vendor);\n    console.log(adapterInfo.architecture);\n    const canTimestamp = adapter.features.has(\"timestamp-query\");\n    if (!canTimestamp) {\n        console.error(\"Timestamp queries are not supported on this device.\");\n        return;\n    }\n    const device = await adapter.requestDevice({\n        requiredFeatures: ['timestamp-query'],\n    });\n    const canvas = document.querySelector('canvas');\n    if (!canvas) {\n        throw new Error('Canvas element not found!');\n    }\n    const context = canvas.getContext('webgpu');\n    if (!context) {\n        throw new Error('WebGPU is not supported on this device or browser.');\n    }\n    const { querySet, resolveBuffer, resultBuffer } = (() => {\n        if (!canTimestamp) {\n            return {};\n        }\n        const querySet = device.createQuerySet({\n            type: 'timestamp',\n            count: 2,\n        });\n        const resolveBuffer = device.createBuffer({\n            size: querySet.count * 8,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n        });\n        const resultBuffer = device.createBuffer({\n            size: resolveBuffer.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        return { querySet, resolveBuffer, resultBuffer };\n    })();\n    if (!querySet) {\n        throw new Error('querySet is not defined!');\n    }\n    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n    context.configure({\n        device: device,\n        format: presentationFormat,\n        alphaMode: \"opaque\",\n    });\n    const cameraUniform = {\n        position: [0.0, 0.0, 5.0],\n        direction: [0.0, 0.0, 0.0],\n        padding: 0.0,\n    };\n    // Define camera uniform\n    const cameraUniformBuffer = device.createBuffer({\n        size: 48,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(cameraUniformBuffer, 0, new Float32Array([\n        ...cameraUniform.position,\n        ...cameraUniform.direction,\n        cameraUniform.padding,\n    ]));\n    const timeUniformBuffer = device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\n                buffer: { type: 'uniform' },\n            },\n        ],\n    });\n    const vertices = new Float32Array([\n        -1, -1,\n        1, -1,\n        -1, 1,\n        1, 1,\n    ]);\n    const vertexBuffer = device.createBuffer({\n        size: vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX,\n        mappedAtCreation: true,\n    });\n    new Float32Array(vertexBuffer.getMappedRange()).set(vertices);\n    vertexBuffer.unmap();\n    // Shader modules\n    const shaderModule = device.createShaderModule({\n        code: shader,\n    });\n    const pipelineLayout = device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayout],\n    });\n    // Pipeline\n    const pipeline = device.createRenderPipeline({\n        layout: pipelineLayout,\n        vertex: {\n            module: shaderModule,\n            entryPoint: \"vs_main\",\n            buffers: [\n                {\n                    arrayStride: 8,\n                    attributes: [\n                        {\n                            shaderLocation: 0,\n                            offset: 0,\n                            format: \"float32x2\",\n                        },\n                    ],\n                },\n            ],\n        },\n        fragment: {\n            module: shaderModule,\n            entryPoint: \"fs_main\",\n            targets: [{ format: presentationFormat }],\n        },\n        primitive: {\n            topology: \"triangle-strip\",\n        },\n    });\n    //const layout = pipeline.getBindGroupLayout(0); // Get the inferred layout\n    const bindGroup = device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [\n            {\n                binding: 0,\n                resource: { buffer: cameraUniformBuffer },\n            },\n            {\n                binding: 1,\n                resource: { buffer: timeUniformBuffer },\n            }\n        ],\n    });\n    let lastTime = performance.now();\n    let totalTime = 0.0;\n    const animationSpeed = 0.001;\n    let gpuTimes = [];\n    // Render loop\n    function render() {\n        const now = performance.now();\n        const deltaTime = now - lastTime;\n        lastTime = now;\n        totalTime += deltaTime * animationSpeed;\n        device.queue.writeBuffer(timeUniformBuffer, 0, new Float32Array([totalTime]));\n        const camera = {\n            position: [0.0, 0.0, 5.0],\n            direction: [0.0, 0.0, -1.0],\n        };\n        device.queue.writeBuffer(cameraUniformBuffer, 0, new Float32Array([...camera.position, ...camera.direction]));\n        const commandEncoder = device.createCommandEncoder();\n        if (!context) {\n            throw new Error('WebGPU is not supported on this device or browser.');\n        }\n        const textureView = context.getCurrentTexture().createView();\n        const renderPass = commandEncoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: textureView,\n                    loadOp: \"clear\",\n                    clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                    storeOp: \"store\",\n                },\n            ],\n            ...(canTimestamp && querySet && {\n                timestampWrites: {\n                    querySet: querySet,\n                    beginningOfPassWriteIndex: 0,\n                    endOfPassWriteIndex: 1,\n                },\n            }),\n        });\n        renderPass.setPipeline(pipeline);\n        renderPass.setBindGroup(0, bindGroup);\n        renderPass.setVertexBuffer(0, vertexBuffer);\n        renderPass.draw(4);\n        renderPass.end();\n        device.queue.submit([commandEncoder.finish()]);\n        // Request next frame\n        requestAnimationFrame(render);\n    }\n    render();\n}\nmain();\n","export default \"@group(0) @binding(0) var<uniform> camera: Camera;\\n@group(0) @binding(1) var<uniform> time: f32;\\n\\nstruct Camera {\\n    position: vec3<f32>,\\n    direction: vec3<f32>,\\n    up: vec3<f32>,\\n    right: vec3<f32>,\\n};\\n\\nfn mandelbulbDE(pos: vec3<f32>, power: f32, maxIterations: u32) -> f32 {\\n    var z = pos;\\n    var dr = 1.0;\\n    var r = 0.0;\\n\\n    for (var i = 0u; i < maxIterations; i = i + 1u) {\\n        r = length(z);\\n\\n        if (r > 2.0) {\\n            break;\\n        }\\n\\n        // Convert to spherical coordinates\\n        let theta = acos(z.z / r);\\n        let phi = atan2(z.y, z.x);\\n\\n        // Scale and rotate\\n        let zr = pow(r, power);\\n        let newTheta = theta * power;\\n        let newPhi = phi * power;\\n\\n        // Convert back to Cartesian coordinates\\n        z = zr * vec3<f32>(\\n            sin(newTheta) * cos(newPhi),\\n            sin(newTheta) * sin(newPhi),\\n            cos(newTheta)\\n        );\\n\\n        z = z + pos;\\n        dr = dr * power * r + 1.0;\\n    }\\n\\n    return 0.5 * log(r) * r / dr;\\n}\\n\\nfn calculateNormal(pos: vec3<f32>, power: f32, maxIterations: u32) -> vec3<f32> {\\n    let epsilon = 0.001;\\n\\n    let dx = mandelbulbDE(pos + vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(epsilon, 0.0, 0.0), power, maxIterations);\\n    let dy = mandelbulbDE(pos + vec3<f32>(0.0, epsilon, 0.0), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(0.0, epsilon, 0.0), power, maxIterations);\\n    let dz = mandelbulbDE(pos + vec3<f32>(0.0, 0.0, epsilon), power, maxIterations) -\\n             mandelbulbDE(pos - vec3<f32>(0.0, 0.0, epsilon), power, maxIterations);\\n\\n    return normalize(vec3<f32>(dx, dy, dz));\\n}\\n\\n\\n// Raymarching Function\\nfn raymarch(rayOrigin: vec3<f32>, rayDirection: vec3<f32>, maxSteps: i32, maxDistance: f32, epsilon: f32) -> vec3<f32> {\\n    var pos = rayOrigin;\\n    for (var i = 0; i < maxSteps; i = i + 1) {\\n\\n        let mandelbulbPower = 1.0 + 3.5 * (sin(time) + 1.0);\\n\\n        let distance = mandelbulbDE(pos, mandelbulbPower, 32u);\\n\\n        //let distance = sphereDE(pos, vec3<f32>(0.0, 0.0, 0.0), 1.0);\\n        if (distance < epsilon) {\\n            //let normal = calculateNormal(pos);\\n            let normal = calculateNormal(pos, 8.0, 32u);\\n\\n            // Light direction\\n            let lightDirection = normalize(vec3<f32>(3.0, -3.0, 1.0));\\n\\n            // Lambertian shading\\n            let diffuse = max(dot(normal, lightDirection), 0.0);\\n\\n            // View direction (camera)\\n            let viewDirection = normalize(rayOrigin - pos);\\n\\n            // Reflect light direction around the normal\\n            let reflection = reflect(-lightDirection, normal);\\n\\n            // Specular shading\\n            let shininess = 48.0; // Adjust for sharper or softer highlights\\n            let specular = pow(max(dot(viewDirection, reflection), 0.0), shininess);\\n\\n            // Ambient light\\n            let ambient = 0.1;\\n\\n            // Combine components\\n            return vec3<f32>(1.0, 0.0, 0.0) * (diffuse + ambient) + vec3<f32>(1.0) * specular; // Add specular\\n        }\\n        if (distance > maxDistance) {\\n            break;\\n        }\\n        pos = pos + rayDirection * distance;\\n    }\\n    return vec3<f32>(0.0, 0.0, 0.0);\\n}\\n\\n@fragment\\nfn fs_main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {\\n    let resolution = vec2<f32>(800.0, 600.0);\\n    let uv = (fragCoord.xy / resolution) * 2.0 - vec2<f32>(1.0, 1.0);\\n\\n    let aspectRatio = resolution.x / resolution.y;\\n    let fov = 60.0 * 3.14159 / 180.0;\\n\\n    // Camera properties\\n    let cameraPosition = vec3<f32>(0.0, 0.0, 5.0);\\n    let object = vec3<f32>(0.0, 0.0, 0.0);\\n    let forward = normalize(object - cameraPosition);\\n    let up = vec3<f32>(0.0, 1.0, 0.0);\\n    let right = normalize(cross(forward, up));\\n    let adjustedUp = cross(right, forward);\\n    \\n    let rayDirection = normalize(\\n        forward +\\n        right * uv.x * aspectRatio * tan(fov / 2.0) +\\n        adjustedUp * uv.y * tan(fov / 2.0)\\n    );\\n\\n    let color = raymarch(cameraPosition, rayDirection, 256, 50.0, 0.001);\\n    return vec4<f32>(color, 1.0);\\n}\\n\\n\\n@vertex\\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {\\n\\n    var positions = array<vec2<f32>, 3>(\\n        vec2<f32>(-1.0, -1.0),\\n        vec2<f32>(3.0, -1.0),\\n        vec2<f32>(-1.0, 3.0)\\n    );\\n\\n    let position = positions[vertexIndex];\\n    return vec4<f32>(position, 0.0, 1.0);\\n}\\n\\n\""],"names":["async","adapter","navigator","gpu","requestAdapter","Error","adapterInfo","info","console","log","vendor","architecture","canTimestamp","features","has","error","device","requestDevice","requiredFeatures","canvas","document","querySelector","context","getContext","querySet","resolveBuffer","resultBuffer","createQuerySet","type","count","createBuffer","size","usage","GPUBufferUsage","QUERY_RESOLVE","COPY_SRC","COPY_DST","MAP_READ","presentationFormat","getPreferredCanvasFormat","configure","format","alphaMode","cameraUniform","position","direction","padding","cameraUniformBuffer","UNIFORM","queue","writeBuffer","Float32Array","timeUniformBuffer","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","VERTEX","buffer","vertices","vertexBuffer","byteLength","mappedAtCreation","getMappedRange","set","unmap","shaderModule","createShaderModule","code","pipelineLayout","createPipelineLayout","bindGroupLayouts","pipeline","createRenderPipeline","layout","vertex","module","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","bindGroup","createBindGroup","resource","lastTime","performance","now","totalTime","render","deltaTime","camera","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","loadOp","clearValue","r","g","b","a","storeOp","timestampWrites","beginningOfPassWriteIndex","endOfPassWriteIndex","setPipeline","setBindGroup","setVertexBuffer","draw","end","submit","finish","requestAnimationFrame","main"],"sourceRoot":""}